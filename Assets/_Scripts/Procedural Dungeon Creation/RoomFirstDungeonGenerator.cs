using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Generates dungeons by first creating rooms using a space partitioning algorithm and then optionally using a random walk method
/// within those rooms to create floors. The class builds on the RandomWalkDungeonGenerator, inheriting its basic generation capabilities
/// and adding room-first specific functionality.
/// </summary>
public class RoomFirstDungeonGenerator : RandomWalkDungeonGenerator
{
    [Header("Min-Settings")]
    [SerializeField] private int minRoomWidth = 4; 
    [SerializeField] private int minRoomHeight = 4; 

    [Header("Settings")] 
    [SerializeField] private int dungeonWidth = 20; 
    [SerializeField] private int dungeonHeight = 20;
    [SerializeField] [Range(0,10)] private int _offset = 1; 
    [SerializeField] private bool isUsingRandomWalkForRooms = false;

    /// <summary>
    /// Overrides the base class method to initiate the procedural generation process specifically tailored for room-first dungeon generation.
    /// </summary>
    protected override void RunProceduralGeneration()
    {
        CreateRooms();
    }

    /// <summary>
    /// Generates rooms and connecting corridors based on the space partitioning algorithm within a specified dungeon area. 
    /// This method first partitions the dungeon into rooms that meet minimum size requirements. It then creates floors within 
    /// these rooms, considering an offset from the room boundaries to ensure floors do not touch the walls directly.
    /// Room centers are calculated and used to connect the rooms with corridors, integrating the entire layout into a cohesive dungeon map.
    /// Finally, the method visualizes the dungeon by building floor tiles and walls using the generated floor and corridor data.
    /// </summary>
    private void CreateRooms()
    {
        List<BoundsInt> roomsList = ProceduralGenerationAlgorithms.SpatialPartitioning(
            new BoundsInt((Vector3Int)startPos,
            new Vector3Int(dungeonWidth, dungeonHeight, 0)), minRoomWidth, minRoomHeight);

        HashSet<Vector2Int> floor = new();
        
        if (isUsingRandomWalkForRooms)
            floor = CreateRoomsRandomly(roomsList);
        else
            floor = CreateSimpleRooms(roomsList);

        List<Vector2Int> roomsCenterPoints = new();

        foreach (var room in roomsList)
        {
            roomsCenterPoints.Add(Vector2Int.RoundToInt(room.center));
        }

        HashSet<Vector2Int> corridors = ConnectRooms(roomsCenterPoints);
        floor.UnionWith(corridors);
        
        tilemapVisualizer.BuildFloorTiles(floor);
        WallGenerator.BuildWalls(floor, tilemapVisualizer);
    }

    /// <summary>
    /// Creates a HashSet floor. Loops through each room passed by the roomsList. Stores each roomBounds and the center of each room.
    /// Creates another hashset building the roomFloor via RandomWalk Algorithm which takes the roomCenter as startPosition.
    /// Then we check if each position of that created roomFloor is inside the given offset, if yes it will be added to the floor.
    /// </summary>
    /// <param name="roomsList">Contains the rooms generated by the Space Partitioning Algorithm</param>
    /// <returns>The entire levels floor</returns>
    private HashSet<Vector2Int> CreateRoomsRandomly(List<BoundsInt> roomsList)
    {
        HashSet<Vector2Int> floor = new();

        for (int i = 0; i < roomsList.Count; i++)
        {
            BoundsInt roomBounds = roomsList[i];

            Vector2Int roomCenter = new Vector2Int(
                Mathf.RoundToInt(roomBounds.center.x),
                Mathf.RoundToInt(roomBounds.center.y)
                );

            HashSet<Vector2Int> roomFloor = RunRandomWalk(_randomWalkParameters, roomCenter);

            foreach (var position in roomFloor)
            {
                if (position.x >= (roomBounds.xMin + _offset) 
                    && position.x <= (roomBounds.xMax - _offset)
                    && position.y >= (roomBounds.yMin + _offset) 
                    && position.y <= (roomBounds.yMax - _offset))
                {
                    floor.Add(position);
                }
            }
        }

        return floor;
    }

    /// <summary>
    /// Generates the floor layout for each room. This method takes a list of room boundaries and creates a floor plan
    /// for each room, applying an offset to avoid placing tiles at the room's boundary. The generated floor plan is then
    /// used to visualize the dungeon layout.
    /// </summary>
    /// <param name="roomsList">A list of room boundaries used to generate the floor plan.</param>
    /// <returns>A HashSet of floor positions representing the walkable area within the rooms.</returns>
    private HashSet<Vector2Int> CreateSimpleRooms(List<BoundsInt> roomsList)
    {
        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();

        foreach (var room in roomsList)
        {
            for (int column = _offset; column < room.size.x - _offset; column++) // Possible place to calculate enemy spawns here
            {
                for (int row = _offset; row < room.size.y - _offset; row++)
                {
                    Vector2Int pos = (Vector2Int)room.min + new Vector2Int(column, row);
                    floor.Add(pos);
                }
            }
        }

        return floor;
    }
    
     /// <summary>
    /// Connects all room centers with corridors to ensure every room of the dungeon is accessible. Starts from a randomly selected room center and connects it
    /// to the closest other room center, repeating the process until all rooms are interconnected. This method ensures that the dungeon's rooms
    /// are fully accessible from each other through the corridors it generates.
    /// </summary>
    /// <param name="roomsCenterPoints">A list of center points of all rooms, used as nodes to connect with corridors.</param>
    /// <returns>A set of corridor positions that connect all room centers.</returns>
    private HashSet<Vector2Int> ConnectRooms(List<Vector2Int> roomsCenterPoints)
    {
        HashSet<Vector2Int> corridors = new();
        Vector2Int currentRoomCenterPoint = roomsCenterPoints[Random.Range(0, roomsCenterPoints.Count)];
        roomsCenterPoints.Remove(currentRoomCenterPoint);

        while (roomsCenterPoints.Count > 0)
        {
            Vector2Int closestCenterPoint = FindClosestCenterPoint(currentRoomCenterPoint, roomsCenterPoints);
            roomsCenterPoints.Remove(closestCenterPoint);
            
            HashSet<Vector2Int> newCorridor = BuildCorridor(currentRoomCenterPoint, closestCenterPoint);
            currentRoomCenterPoint = closestCenterPoint;
            corridors.UnionWith(newCorridor);
        }

        return corridors;
    }

    /// <summary>
    /// Compares every center point available to the currentRoomCenterPoint and checks for the closest distance between them.
    /// </summary>
    /// <param name="currentRoomCenterPoint">Center Point of the current room</param>
    /// <param name="roomsCenterPoint">A list of all room center points</param>
    /// <returns>The closest other center Point of the currentRoomCenterPoint</returns>
    private Vector2Int FindClosestCenterPoint(Vector2Int currentRoomCenterPoint, List<Vector2Int> roomsCenterPoint)
    {
        Vector2Int closestPoint = Vector2Int.zero;
        float distance = float.MaxValue;
        
        foreach (var position in roomsCenterPoint)
        {
            float currentDistance = Vector2Int.Distance(position, currentRoomCenterPoint);
            if (currentDistance < distance)
                closestPoint = position;
        }

        return closestPoint;
    }
    
    /// <summary>
    /// Builds a straight corridor between two room centers, one segment at a time, first vertically then horizontally. This method ensures the corridor 
    /// connects directly and linearly from the start point to the destination.
    /// </summary>
    /// <param name="currentRoomCenter">The starting point of the corridor.</param>
    /// <param name="destination">The endpoint of the corridor.</param>
    private HashSet<Vector2Int> BuildCorridor(Vector2Int currentRoomCenter, Vector2Int destination)
    {
        HashSet<Vector2Int> corridor = new();
        Vector2Int pos = currentRoomCenter;
        corridor.Add(pos);

        while (pos.y != destination.y)
        {
            if (pos.y > destination.y)
                pos += Vector2Int.down;
            else if (pos.y < destination.y)
                pos += Vector2Int.up;

            corridor.Add(pos);
            corridor.Add(pos + Vector2Int.right);
        }

        while (pos.x != destination.x)
        {
            if (pos.x > destination.x)
                pos += Vector2Int.left;
            else if (pos.x < destination.x)
                pos += Vector2Int.right;

            corridor.Add(pos);
            corridor.Add(pos + Vector2Int.up);
        }

        return corridor;
    }
}
